// Generated by CoffeeScript 1.6.3
(function() {
  var controllers;

  controllers = angular.module("engineControllers", []);

  controllers.controller("TabsCtrl", function($scope, $location) {
    $scope.tabs = [
      {
        link: "data",
        label: "Manage Dataset"
      }, {
        link: "ontology",
        label: "Edit Ontology"
      }, {
        link: "visualize",
        label: "Select Visualizations"
      }, {
        link: "assemble",
        label: "Assemble Engine"
      }
    ];
    $scope.selectedTab = $scope.tabs[0];
    $scope.setSelectedTab = function(tab) {
      return $scope.selectedTab = tab;
    };
    return $scope.tabClass = function(tab) {
      if ($scope.selectedTab === tab) {
        return "active";
      } else {
        return "";
      }
    };
  });

  controllers.controller("DatasetListCtrl", function($scope, $http, DataService) {
    var files;
    files = void 0;
    $("#data-file").on("change", function(event) {
      files = event.target.files;
    });
    $("#data-submit").click(function(event) {
      var data;
      data = new FormData();
      data.append("dataset", files[0]);
      $.ajax({
        url: "/upload",
        type: "POST",
        data: data,
        cache: false,
        processData: false,
        contentType: false
      }).success(function(data) {
        if (data.status === "success") {
          delete data["status"];
          $scope.$apply(function() {
            var i;
            data.title = data.filename;
            data.colAttrs = [];
            i = 0;
            while (i < data.cols) {
              data.colAttrs[i] = {
                name: data.header[i],
                type: data.types[i]
              };
              i++;
            }
            delete data["header"];
            delete data["types"];
            $scope.datasets.push(data);
          });
        }
      });
    });
    $scope.selected_index = 0;
    $scope.select_dataset = function(index) {
      $scope.selected_index = index;
    };
    $scope.types = ["int", "float", "str"];
    $scope.datasets = DataService.getData();
  });

  controllers.controller("OntologyEditorCtrl", function($scope, $http, DataService, OverlapService) {
    var relnData;
    $scope.datasets = DataService.getData();
    relnData = OverlapService.getData();
    $scope.overlaps = relnData.overlaps;
    $scope.hierarchies = relnData.hierarchies;
  });

  controllers.controller("CreateVizCtrl", function($scope, $http, DataService, OverlapService, VizDataService, VizFromOntologyService) {
    var columnPair, columnPairList, d, dataset, datasetPair, datasetPairList, datasets, edge, edges, hierarchy, i, initNetwork, node, nodes, relnData, type;
    datasets = DataService.getData();
    $scope.datasets = datasets;
    relnData = OverlapService.getData();
    nodes = [];
    edges = [];
    i = 0;
    while (i < datasets.length) {
      dataset = datasets[i];
      node = {
        model: dataset.dataset_id,
        attrs: dataset.column_attrs,
        unique_cols: dataset.unique_cols
      };
      nodes.push(node);
      i++;
    }
    for (datasetPair in relnData.hierarchies) {
      hierarchy = relnData.hierarchies[datasetPair];
      datasetPairList = datasetPair.split("\t");
      for (columnPair in hierarchy) {
        type = hierarchy[columnPair];
        columnPairList = columnPair.split("\t");
        d = relnData.overlaps[datasetPair][columnPair];
        if (d > 0.5) {
          edge = {
            source: [parseInt(datasetPairList[0]), parseInt(columnPairList[1])],
            target: [parseInt(datasetPairList[1]), parseInt(columnPairList[1])],
            type: type
          };
          edges.push(edge);
        }
      }
    }
    initNetwork = {
      nodes: nodes,
      edges: edges
    };
    $scope.initNetwork = initNetwork;
    $scope.vizType = "treemap";
    $scope.selected_vizType_index = 1;
    $scope.select_vizType = function(index) {
      $scope.vizType = $scope.vizTypes[index].name;
      $scope.selected_vizType_index = index;
      $scope.vizSpecs = $scope.allVizSpecs[$scope.selected_vizType];
    };
    $scope.selected_vizSpec_index = 0;
    $scope.select_vizSpec = function(index) {
      $scope.selected_vizSpec_index = index;
    };
    $scope.getDatasetTitle = function(dataset_id) {
      return datasets[dataset_id].title;
    };
    $scope.getColumnName = function(dataset_id, column_id) {
      return datasets[dataset_id].column_attrs[column_id].name;
    };
    $scope.vizFromOntology = function() {
      VizFromOntologyService.promise($scope.initNetwork, function(data) {
        var visualization, visualizations, vizTypes;
        visualizations = data.visualizations;
        vizTypes = [];
        for (visualization in visualizations) {
          vizTypes.push({
            name: visualization,
            count: visualizations[visualization].length
          });
        }
        $scope.vizTypes = vizTypes;
        $scope.vizSpecs = visualizations[$scope.vizType];
        $scope.allVizSpecs = visualizations;
      });
    };
    $scope.vizFromOntology();
    $scope.setVizData = function(vizSpec) {
      $scope.vizSpec = vizSpec;
      VizDataService.promise(vizSpec, function(result) {
        $scope.vizData = result.result;
      });
    };
  });

}).call(this);
